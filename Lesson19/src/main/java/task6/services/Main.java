package task6.services;

import task6.models.Book;
import task6.models.EmailAddress;
import task6.models.Library;
import task6.models.Reader;

import java.util.Comparator;
import java.util.List;

//6) Пишем библиотеку.
//        * Для каждой книги библиотечного фонда известны автор, название и год издания.
//        * Для читателя библиотеки будем хранить ФИО и электронный адрес. Каждый читатель может взять в библиотеке одну или несколько книг.
//        * Ещё нам понадобится флаг читательского согласия на уведомления по электронной почте.
//        * Рассылки организуют сотрудники библиотеки: напоминают о сроке возврата книг, сообщают новости.
//        * Создаем классы:
//        *  - Book с полями Автор, Название, Год издания
//        *  - Reader(читатель) с полями ФИО, электронный адрес, флаг согласия на рассылку, список взятых книг
//        *  - EmailAddress с полями электронный адрес, дополнительная информация
//        *  - Library содержит список книг и список читателей.
//        *
//        *  Задачи:
//        *  a) Получить список всех книг библиотеки, отсортированных по году издания.
//        *  b) Требуется создать список рассылки (объекты типа EmailAddress) из адресов всех читателей библиотеки.
//        *      При этом флаг согласия на рассылку учитывать не будем: библиотека закрывается, так что хотим оповестить всех.
//        *  c) Снова нужно получить список рассылки. Но на этот раз включаем в него только адреса читателей, которые согласились на рассылку.
//        *      Дополнительно нужно проверить, что читатель взял из библиотеки больше одной книги.
//        *  d) Получить список всех книг, взятых читателями.
//        *      Список не должен содержать дубликатов (книг одного автора, с одинаковым названием и годом издания).
//        *  e) Проверить, взял ли кто-то из читателей библиотеки какие-нибудь книги Пушкина Александра Сергеевича.
//        *
//        *  Задачи со ЗВЕЗДОЧКОЙ:
//        *  а) Узнать наибольшее число книг, которое сейчас на руках у читателя.
//        *  b) Необходимо рассылать разные тексты двум группам:
//        *      * тем, у кого взято меньше двух книг, просто расскажем о новинках библиотеки;
//        *      * тем, у кого две книги и больше, напомним о том, что их нужно вернуть в срок.
//        *      То есть надо написать метод, который вернёт два списка адресов (типа EmailAddress): с пометкой OK — если книг не больше двух,
//        *      или TOO_MUCH — если их две и больше. Порядок групп не важен.
//        *  с) Для каждой группы (OK, TOO_MUCH) получить списки читателей в каждой группе.
//        *  d) Для каждой группы (OK, TOO_MUCH) получить ФИО читателей в каждой группе, перечисленные через запятую.
//        *      И ещё каждый такой список ФИО нужно обернуть фигурными скобками.
//        *      Пример: TOO_MUCH {Иванов Иван Иванович, Васильев Василий Васильевич}
//        *              OK {Семёнов Семён Семёнович}
public class Main {
    public static void main(String[] args) {
        Library library = new Library();
        library.getBooks().add(new Book("Лев Толстой", "Война и мир", 1891));
        library.getBooks().add(new Book("Булгаков", "Мастер и Маргарита", 1928));
        library.getBooks().add(new Book("Достоевский", "Бесы", 1872));
        library.getBooks().add(new Book("Достоевский", "Идиот", 1869));
        library.getBooks().add(new Book("Пушкин", "Дубровский", 1841));

//      Получить список всех книг библиотеки, отсортированных по году издания.
        library.getBooks().stream()
                .sorted(Comparator.comparing(Book::getTheYearOfPublishing))
                .map(Book::toString)
                .forEach(System.out::println);

//      Требуется создать список рассылки (объекты типа EmailAddress) из адресов всех читателей библиотеки.
//      При этом флаг согласия на рассылку учитывать не будем: библиотека закрывается, так что хотим оповестить всех.
        List<EmailAddress> emailAddressList = library.getReaders().stream()
                .map(Reader::getEMailAddress)
                .map(EmailAddress::new)
                .toList();

//      Снова нужно получить список рассылки. Но на этот раз включаем в него только адреса читателей, которые согласились на рассылку.
//      Дополнительно нужно проверить, что читатель взял из библиотеки больше одной книги.
        List<EmailAddress> subscriberList = library.getReaders().stream()
                .filter(Reader::isAgreement)
                .filter(reader -> reader.getReadersBooks().size() > 1)
                .map(Reader::getEMailAddress)
                .map(EmailAddress::new)
                .toList();

//      Получить список всех книг, взятых читателями.
//      Список не должен содержать дубликатов (книг одного автора, с одинаковым названием и годом издания).
        List<Book> books = library.getReaders().stream()
                .flatMap(reader -> reader.getReadersBooks().stream())
                .distinct()
                .toList();

//      Проверить, взял ли кто-то из читателей библиотеки какие-нибудь книги Пушкина Александра Сергеевича.
        boolean match = library.getReaders().stream()
                .flatMap(reader -> reader.getReadersBooks().stream())
                .distinct()
                .anyMatch(book -> "Пушкин".equals(book.getAuthor()));
    }
}
